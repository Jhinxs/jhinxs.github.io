[{"categories":null,"content":"暂无 ","date":"0001-01-01","objectID":"/about/aboutme/:0:0","tags":null,"title":"About Me","uri":"/about/aboutme/"},{"categories":["programming"],"content":"之前用的Ollvm基于LLVM4的实在在是太老了，看到了几个新一点的项目就拿来编译瞅瞅，在Windows下编译的过程过于坎坷，一共编译成功了两个项目，这里分别记录一下，以供查查 https://github.com/bluesadi/Pluto-Obfuscator https://github.com/lemon4ex/obfuscator/tree/llvm-13.0 *注： （1）都需要安装ninja编译工具：https://github.com/ninja-build/ninja/releases/tag/v1.10.2 （ninja编译速度快） （2）要在VS中安装Clang编译集成工具 （3）在项目工程文件夹中，新建Directory.build.props 文件，内容如下，路径为你的即可： \u003cProject\u003e \u003cPropertyGroup\u003e \u003cLLVMInstallDir\u003eD:\\Pluto-Obfuscator\\build\u003c/LLVMInstallDir\u003e \u003cLLVMToolsVersion\u003e12.0.1\u003c/LLVMToolsVersion\u003e \u003c/PropertyGroup\u003e \u003c/Project\u003e ","date":"2022-07-22","objectID":"/ollvm-windows%E4%B8%8B%E7%BC%96%E8%AF%91%E5%8F%8Avs%E9%9B%86%E6%88%90/:0:0","tags":["Code"],"title":"Ollvm Windows下编译及VS集成","uri":"/ollvm-windows%E4%B8%8B%E7%BC%96%E8%AF%91%E5%8F%8Avs%E9%9B%86%E6%88%90/"},{"categories":["programming"],"content":"Ollvm13 项目地址：https://github.com/lemon4ex/obfuscator/tree/llvm-13.0 这个项目编译的过程: 编译命令 进入VS开发者命令行建议管理员，建议关闭杀软 G:\\VisualStudio2019\\VisualStudio2019\\VC\\Auxiliary\\Build\\vcvarsall.bat x64 cd obfuscator-llvm-13.0 mkdir build cd build cmake -G \"Ninja\" -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_NEW_PASS_MANAGER=OFF -DLLVM_INCLUDE_TESTS=OFF .. ninja 编译完后再bin目录下看到生成的clang等exe表示成功，编译过程中产生的warning可忽略 混淆命令 控制流扁平化 这个模式主要是把一些if-else语句，嵌套成do-while语句 -mllvm -fla：激活控制流扁平化 -mllvm -split：激活基本块分割。在一起使用时改善展平。 -mllvm -split_num=3：如果激活了传递，则在每个基本块上应用3次。默认值：1 指令替换 这个模式主要用功能上等效但更复杂的指令序列替换标准二元运算符(+ , – , \u0026 , | 和 ^) -mllvm -sub：激活指令替换 -mllvm -sub_loop=3：如果激活了传递，则在函数上应用3次。默认值：1 虚假控制流程 这个模式主要嵌套几层判断逻辑，一个简单的运算都会在外面包几层if-else，所以这个模式加上编译速度会慢很多因为要做几层假的逻辑包裹真正有用的代码。 另外说一下这个模式编译的时候要浪费相当长时间包哪几层不是闹得！ -mllvm -bcf：激活虚假控制流程 -mllvm -bcf_loop=3：如果激活了传递，则在函数上应用3次。默认值：1 -mllvm -bcf_prob=40：如果激活了传递，基本块将以40％的概率进行模糊处理。默认值：30 ##### https://heroims.github.io/2019/01/06/OLLVM%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E7%A7%BB%E6%A4%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/ 错误处理 编译过程中可能会出的错误以及处理方法： 1.编译中出现：修复常量中有换行符错误类似字眼 将文件编码改为utf-8-BOM， 使用 vscode 打开文件，选择“编码保存为”-\u003e“UTF8-8 BOM 编码“ 基本上是这几个文件 \\clang-tools-extra\\clangd\\Diagnostics.cpp(491): error C2001: 常量中有换行符 \\clang-tools-extra\\clangd\\Hover.cpp(578): error C2001: 常量中有换行符 \\clang-tools-extra\\clangd\\CodeComplete.h(81): error C2001: 常量中有换行符 \\clang-tools-extra\\clangd\\Selection.cpp : error C2001: 常量中有换行符 2.clang编译时没问题，但是编译C++二进制文件后发现混淆不生效 cmake的时候加 -DLLVM_ENABLE_NEW_PASS_MANAGER=OFF ，这个是llvm 13.x版本的特性问题 3.lld-link.exe未找到 复制到vs的llvmlld-link.exe到Ollvm编译完的bin目录下，于clang同目录 G:\\VisualStudio2019\\VisualStudio2019\\VC\\Tools\\Llvm\\x64\\bin\\lld-link.exe ","date":"2022-07-22","objectID":"/ollvm-windows%E4%B8%8B%E7%BC%96%E8%AF%91%E5%8F%8Avs%E9%9B%86%E6%88%90/:0:1","tags":["Code"],"title":"Ollvm Windows下编译及VS集成","uri":"/ollvm-windows%E4%B8%8B%E7%BC%96%E8%AF%91%E5%8F%8Avs%E9%9B%86%E6%88%90/"},{"categories":["programming"],"content":"Pluto-Obfuscator 项目地址：https://github.com/bluesadi/Pluto-Obfuscator 编译命令 进入VS开发者命令行建议管理员，建议关闭杀软 G:\\VisualStudio2019\\VisualStudio2019\\VC\\Auxiliary\\Build\\vcvarsall.bat x64 cd Pluto-Obfuscator mkdir build cd build cmake -G \"Ninja\" -DLLVM_ENABLE_PROJECTS=\"clang\" -DCMAKE_BUILD_TYPE=Release -DLLVM_TARGETS_TO_BUILD=\"X86\" -DBUILD_SHARED_LIBS=off -DCMAKE_INSTALL_PREFIX=\"../install\" ../llvm ninja 编译完后再bin目录下看到生成的clang等exe表示成功，编译过程中产生的warning可忽略 错误处理 1.“Unknown endianness of the compilation platform, check this header aes_encrypt.h” 打开Obfuscation/CryptoUtils.h文件,并为修改如下，之前应该是没有_WIN32宏定义： #if defined(__i386) || defined(__i386__) || defined(_M_IX86) || \\ defined(INTEL_CC) || defined(_WIN64) || defined(_WIN32) 2.错误类似：“FAILED: xxxxxx.cpp, warning C4819: 该文件包含不能 在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失,error C3861: “alterVal”: 找不到标识符” 这个错误因为这些文件中存在中文注释，格式有误导致，要么所有的文件修改格式为Unicode，要么删除苏所有文件中的中文注释。但是都很麻烦，文件太多了。这里可以打开build文件下的build.ninja文件，用vscode或者其他文件编辑工具，搜索并替换，加入/utf-8的编译选项，例如搜索 /DNDEBUG 并替换为 /DNDEBUG /utf-8。我对这个编译不熟，可能有其他的更方便的办法。。。。不过这个方法有效！ 混淆命令 -mllvm -mba -mllvm -mba-prob=50 -mllvm -fla-ex -mllvm -gle 或者参考项目地址的说明 ","date":"2022-07-22","objectID":"/ollvm-windows%E4%B8%8B%E7%BC%96%E8%AF%91%E5%8F%8Avs%E9%9B%86%E6%88%90/:0:2","tags":["Code"],"title":"Ollvm Windows下编译及VS集成","uri":"/ollvm-windows%E4%B8%8B%E7%BC%96%E8%AF%91%E5%8F%8Avs%E9%9B%86%E6%88%90/"},{"categories":["programming"],"content":"总结 放到IDA里的效果来看的话，Pluto-Obfuscator效果更符合本人使用需求，并且一直在更新，可以试试。 ","date":"2022-07-22","objectID":"/ollvm-windows%E4%B8%8B%E7%BC%96%E8%AF%91%E5%8F%8Avs%E9%9B%86%E6%88%90/:0:3","tags":["Code"],"title":"Ollvm Windows下编译及VS集成","uri":"/ollvm-windows%E4%B8%8B%E7%BC%96%E8%AF%91%E5%8F%8Avs%E9%9B%86%E6%88%90/"},{"categories":["Windows OS"],"content":"x86 Call Stack 在x86下，一般函数的调用栈帧的结构大概如下: 在管理栈空间中，最主要的两个寄存器分别为EBP以及ESP,EBP表示为当前函数栈的开始，也就是栈底，而ESP则用于提升栈空间，表示为栈顶。 void add() { printf(\"test\"); } void test() { int c = 1; int b = 2; add(); } 反汇编上述代码我们大致可以看到类似如下的汇编语句: push ebp mov ebp,esp sub esp,xxxH mov dword ptr [ebp-4h],1 mov dword ptr [ebp-8h],2 call add add esp,xxxH mov esp,ebp pop ebp ret 结合上图不难看出，在x86下，通过EBP可以寻址当前函数体内的局部变量，函数参数，也可以找到函数返回地址，父函数的栈空间，例如：EBP-XXXH 通常表示当前函数内的局部变量，EBP+4 的位置则是返回地址，EBP+8 的位置可能是函数的参数。如此一来，不难看出通过EBP加正数偏移可以引用父函数的地址空间，加负数偏移可以引用当前函数的地址空间。 进入函数内首先保存了旧的EBP，所以当前EBP所指向的4字节内存单元保存的就是父函数的EBP,同样的可以根据此EBP找到其返回地址等信息，然后依次向上遍历，直到当前线程的最顶层的函数位置，这也就是基本的栈回溯过程。 ","date":"2022-05-22","objectID":"/x86%E4%B8%8Ex64%E6%A0%88%E5%9B%9E%E6%BA%AF/:1:0","tags":["OS"],"title":"x86与x64栈回溯","uri":"/x86%E4%B8%8Ex64%E6%A0%88%E5%9B%9E%E6%BA%AF/"},{"categories":["Windows OS"],"content":"x86 模拟栈回溯 微软提供了API stackwalk64 可以帮我们实现类似的功能. 其内部实现原理可以参考:StackWalk64栈回溯原理解析 借此我们可以实现一个简单的栈回溯过程： CONTEXT context = { 0 }; context.ContextFlags = CONTEXT_ALL; GetThreadContext(thread,\u0026context); STACKFRAME64 stackframe = { 0 }; stackframe.AddrPC.Offset = context.Eip; stackframe.AddrPC.Mode = AddrModeFlat; stackframe.AddrFrame.Offset = context.Ebp; stackframe.AddrFrame.Mode = AddrModeFlat; stackframe.AddrStack.Offset = context.Esp; stackframe.AddrStack.Mode = AddrModeFlat; stackframe.AddrReturn.Offset = context.Eax; stackframe.AddrStack.Mode = AddrModeFlat; while (true) { bool res = StackWalk64(IMAGE_FILE_MACHINE_I386, GetCurrentProcess(), thread, \u0026stackframe, \u0026context, NULL, NULL, NULL, NULL); if (!res) { break; } printf(\"ESP:%x \", stackframe.AddrStack.Offset); printf(\"EBP:%x \", stackframe.AddrFrame.Offset); printf(\"RET:%x\\n\", stackframe.AddrReturn.Offset); } ","date":"2022-05-22","objectID":"/x86%E4%B8%8Ex64%E6%A0%88%E5%9B%9E%E6%BA%AF/:1:1","tags":["OS"],"title":"x86与x64栈回溯","uri":"/x86%E4%B8%8Ex64%E6%A0%88%E5%9B%9E%E6%BA%AF/"},{"categories":["Windows OS"],"content":"Thread Stack Spoof 这里有两个比较好的项目:https://github.com/mgeeky/ThreadStackSpoofer 以及 https://github.com/countercept/CallStackSpoofer 终端安全防御产品对基于进程以及线程的创建时检测已经不是什么新鲜事了，或者又如一些验证性开源项目：https://github.com/huoji120/DuckMemoryScan 安全防御产品可以检测线程的创建，并对线程做栈回溯，对其所在的内存区域做扫描查杀获取做一些其他的检测 其实可以看到，栈回溯的过程中一旦某个函数栈发生断裂，那么对于该线程的栈回溯就无法完成，所以就可以对如返回地址等影响栈回溯的地方做手脚，干扰检测 x86函数的返回地址一般是EBP + 4的位置，所以我们可以构造一个假的返回地址. 我们通过RtlCaptureContext捕获线程当前上下文的信息（父函数的寄存器现场），得到EBP从而修改返回地址 CONTEXT context = { 0 }; context.ContextFlags = CONTEXT_ALL; RtlCaptureContext(\u0026context); ULONG_PTR ret = *(int*)(context.Ebp + 4); //正确的返回地址 *(int*)(context.Ebp + 4) = 0; //修改返回地址 我们通过windbg可以看到修改后的效果: 当然直接断开调用栈，程序运行肯定出错，这就需要你适时的恢复正确的调用栈。 ","date":"2022-05-22","objectID":"/x86%E4%B8%8Ex64%E6%A0%88%E5%9B%9E%E6%BA%AF/:1:2","tags":["OS"],"title":"x86与x64栈回溯","uri":"/x86%E4%B8%8Ex64%E6%A0%88%E5%9B%9E%E6%BA%AF/"},{"categories":["Windows OS"],"content":"x64 Call Stack 在x64中，RBP不再充当栈帧（栈底）寄存器，栈顶以及栈底全部经由RSP寄存器充当。 以上述test函数为例，再debug以及release版本中，反汇编大概如下： Debug: push rbp push rdi sub rsp,128h lea rbp,[rsp+20h] mov dword ptr [rbp+4],1 mov dword ptr [rbp+24h],2 call ctest!add lea rsp,[rbp+108h] pop rdi pop rbp ret Release: sub rsp,38h mov dword ptr [rsp+20h],1 mov dword ptr [rsp+24h],2 call ctest!add add rsp,38h ret 再debug中RBP只作为了普通的非易失寄存器压栈保留，其中mov dword ptr [rbp+4],1 类似代码看起来像是再通过RBP寻址，其实归根还是通过RSP，rbp只是作为RSP临时开辟堆栈空间后的一个基准，也是便于调试分析，而在release版本中，开启了优化，直接能更清晰的看到通过RSP进行的栈空间访问。 ","date":"2022-05-22","objectID":"/x86%E4%B8%8Ex64%E6%A0%88%E5%9B%9E%E6%BA%AF/:2:0","tags":["OS"],"title":"x86与x64栈回溯","uri":"/x86%E4%B8%8Ex64%E6%A0%88%E5%9B%9E%E6%BA%AF/"},{"categories":["Windows OS"],"content":"x64 栈回溯 在学习x64栈回溯之前，需要先了解Runtime_Function,Unwind_Info,Unwind_Code等概念。 64位的PE结构中多了一个.pdata段，静态存贮异常处理信息的地方，其中有大量的Runtime_Function Runtime_Function 每个非叶函数都包含一个与之对应的Runtime_Function结构体（叶函数就是不会调用其他函数的函数） Runtime_Function结构体构成 MSDN typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY { DWORD BeginAddress; DWORD EndAddress; union { DWORD UnwindInfoAddress; DWORD UnwindData; } DUMMYUNIONNAME; } RUNTIME_FUNCTION, *PRUNTIME_FUNCTION, _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY; 其中BeginAddress和EndAddress分别表示函数开始地址与结束地址的RVA,而UnwindInfoAddress则是一个指向Unwind_Info结构体的地址。 我们可以使用windbg查看函数对应的Runtime_Function信息: 0:001\u003e .fnent ctest!main Debugger function entry 00000293`c6462c20 for: Exact matches: ctest!main (int, char **) BeginAddress = 00000000`000010b0 EndAddress = 00000000`000010e1 UnwindInfoAddress = 00000000`0001caa8 Unwind info at 00007ff7`b0f1caa8, 6 bytes version 1, flags 0, prolog d, codes 1 00: offs d, unwind op 2, op info 4 UWOP_ALLOC_SMALL. 通过BeginAddress我们可以得到main函数的起始地址: 0:001\u003e lm start end module name 00007ff7`b0f00000 00007ff7`b0f26000 ctest C (private pdb symbols) 00007ff9`8e060000 00007ff9`8e32d000 KERNELBASE (deferred) 00007ff9`8f5b0000 00007ff9`8f66d000 KERNEL32 (pdb symbols) 00007ff9`908d0000 00007ff9`90ac7000 ntdll (pdb symbols) 0:001\u003e ?00007ff7`b0f00000+00000000`000010b0 Evaluate expression: 140701802172592 = 00007ff7`b0f010b0 0:001\u003e u 00007ff7`b0f010b0 ctest!main: 00007ff7`b0f010b0 4889542410 mov qword ptr [rsp+10h],rdx 00007ff7`b0f010b5 894c2408 mov dword ptr [rsp+8],ecx 00007ff7`b0f010b9 4883ec28 sub rsp,28h 00007ff7`b0f010bd e86effffff call ctest!test (00007ff7`b0f01030) Unwind_Info 而Unwind_Info则相对要复杂一些 MSDN typedef union _UNWIND_CODE { struct { UBYTE Offset; UBYTE UnwindOp :4 UBYTE OpInfo :4 }; USHORT FrameOffset; } UNWIND_CODE, *PUNWIND_CODE; typedef struct _UNWIND_INFO { UBYTE Version :3 UBYTE Flags :5 UBYTE SizeOfProlog; UBYTE CountOfCodes; UBYTE FrameRegister :4 UBYTE FrameOffset :4 UNWIND_CODE UnwindCode[1]; } UNWIND_INFO, *PUNWIND_INFO; 比较关","date":"2022-05-22","objectID":"/x86%E4%B8%8Ex64%E6%A0%88%E5%9B%9E%E6%BA%AF/:2:1","tags":["OS"],"title":"x86与x64栈回溯","uri":"/x86%E4%B8%8Ex64%E6%A0%88%E5%9B%9E%E6%BA%AF/"},{"categories":["Windows OS"],"content":"回溯调用栈 根据对RUNTIME_FUNCTION以及UNWIND_INFO的分析，我们可以得到每个函数的栈帧的空间，也就是得到子函数的RSP我们就可以推算出父函数的堆栈空间。 例如windbg如下的调用栈: 0:000\u003e knf # Memory Child-SP RetAddr Call Site 00 000000b7`4b16fca8 00007ff7`25611009 ctest!sub 01 8 000000b7`4b16fcb0 00007ff7`25611049 ctest!add+0x9 02 30 000000b7`4b16fce0 00007ff7`256110c2 ctest!test+0x19 03 40 000000b7`4b16fd20 00007ff7`25611400 ctest!main+0x12 04 30 (Inline Function) --------`-------- ctest!invoke_main+0x22 ........... Child-SP表示子函数初始化完成后的RSP状态值，例如这里add函数调用sub，会有sub RSP,xxxH,CALL SUB这个过程，Child-SP就表示Call之前的RSP，也就是当前函数的初始RSP。（任何还未展开的函数，在windbg中memory显示为空，下一行的8因为压入了返回值占用8个字节） 这里add函数RSP为000000b7`4b16fcb0，根据X64函数的栈帧结构，栈帧的大小=返回地址（8 个字节）+不可变寄存器+局部变量+基于栈的参数+基于寄存 器的参数（shadow space-\u003e0x20h个字节）= 返回地址（8个字节）+ unwind_code得出堆栈空间改变大小。 add函数的Unwind信息如下： 0:000\u003e .fnent ctest!add Debugger function entry 00000196`75b733c0 for: Exact matches: ctest!add (void) BeginAddress = 00000000`00001000 EndAddress = 00000000`0000100e UnwindInfoAddress = 00000000`0001ca98 Unwind info at 00007ff7`2562ca98, 6 bytes version 1, flags 0, prolog 4, codes 1 00: offs 4, unwind op 2, op info 4 UWOP_ALLOC_SMALL. 所以栈帧大小为8+(4*8+8)=0x30h,所以其父函数的RSP=000000b7~4b16fcb0+0x30 = 000000b7~4b16fce0,Windbg中当前函数栈帧的大小位于下一行的Memory中。 而返回地址怎么算呢，以add函数的反汇编为例： 0:000\u003e u ctest!add 00007ff7`25611000 4883ec28 sub rsp,28h 00007ff7`25611004 e807000000 call ctest!sub (00007ff7`25611010) 00007ff7`25611009 4883c428 add rsp,28h 00007ff7`2561100d c3 ret sub rsp,28h后即child-sp,因为调用call之后，会 push ret地址，所以返回地址就在child-sp+unwind_code得出堆栈空间改变大小的地址处 0:000\u003e .fnent ctest!add Debugger function entry 00000196`75b733c0 for: Exact matches: ctest!add (void) BeginAddress = 00000000`00001000 EndAddress = 00000000`0000100e UnwindInfoAddress = 00000000`0001ca98 Unwind info at 00007ff7`2562ca98, 6 bytes version 1, flags 0, prolog 4, codes 1 00: offs 4, unwind op 2, op info 4 UWOP_ALLOC_SMALL. 0:000\u003e dq 000000b7`4b16fcb0+(4*8+8) 000000b7`4b16fcd8 00007ff7`25611049 00000000`00000002 000000b7`4b16fce8 00007ff7`256112e6 00007ff7`25624280 ","date":"2022-05-22","objectID":"/x86%E4%B8%8Ex64%E6%A0%88%E5%9B%9E%E6%BA%AF/:2:2","tags":["OS"],"title":"x86与x64栈回溯","uri":"/x86%E4%B8%8Ex64%E6%A0%88%E5%9B%9E%E6%BA%AF/"},{"categories":["Windows OS"],"content":"代码模拟x64栈回溯 我们可以根据上面的那些结构体信息来模拟栈回溯了，同样的Windows提供了对应的API来利用这些信息完成栈回溯。 RtlLookupFunctionEntry NTSYSAPI PRUNTIME_FUNCTION RtlLookupFunctionEntry( [in] DWORD64 ControlPc, [out] PDWORD64 ImageBase, [out] PUNWIND_HISTORY_TABLE HistoryTable ); RtlVirtualUnwind NTSYSAPI PEXCEPTION_ROUTINE RtlVirtualUnwind( [in] DWORD HandlerType, [in] DWORD64 ImageBase, [in] DWORD64 ControlPc, [in] PRUNTIME_FUNCTION FunctionEntry, [in, out] PCONTEXT ContextRecord, [out] PVOID *HandlerData, [out] PDWORD64 EstablisherFrame, [in, out, optional] PKNONVOLATILE_CONTEXT_POINTERS ContextPointers ); 简单的示例代码： #include \u003cWindows.h\u003e#include \u003cstdio.h\u003e#include \u003ciostream\u003e#include \u003cTlHelp32.h\u003e#include \u003cwinnt.h\u003e#include \u003cdbghelp.h\u003e#pragma comment(lib,\"dbghelp.lib\") void my_StackWalk(CONTEXT context) { UNWIND_HISTORY_TABLE unwind_table = { 0 }; PRUNTIME_FUNCTION pruntime_function; DWORD64 imagebase; KNONVOLATILE_CONTEXT_POINTERS knvcp = { 0 }; PVOID handledata; DWORD64 establishframe; for (;;) { pruntime_function = RtlLookupFunctionEntry(context.Rip, \u0026imagebase, \u0026unwind_table); RtlVirtualUnwind(UNW_FLAG_NHANDLER, imagebase, context.Rip, pruntime_function, \u0026context, \u0026handledata, \u0026establishframe, \u0026knvcp); if (!context.Rip) { break; } printf(\"RSP:%llx \", establishframe); printf(\"RIP:%llx\\n\", context.Rip); } } void sub() { Sleep(INFINITE); } void add() { sub(); } void test() { int c = 1; int b = 2; add(); } int main(int argc, char** argv) { HANDLE thread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)test, NULL, 0, NULL); WaitForSingleObject(thread, 1000); CONTEXT context = { 0 }; context.ContextFlags = CONTEXT_ALL; GetThreadContext(thread,\u0026context); my_StackWalk(context); system(\"pause\"); } 我们创建一个线程运行我们需要进行做回溯的代码，待线程启动后我们使用GetThreadContext获取线程的有效上下文，此时的捕获到的上下文处于Sleep底层函数ntdll!NtDelayExecution从内核返回用户层的那一刻，可以通过windbg调试查看对应的上下文信息。RtlLookupFunctionEntry获取对应函数的RUNTIME_FUNCTION信息。 我们得到了子函数的堆栈信息就可以开始进行回溯了，通过RtlVirtualUnwind API就可以完成这个过程。 RtlVirtualUnwind是如何做模拟展开的呢，其实也是解析unwind_info信息，做一些反向回滚之类的操作。 windbg调用栈信息: 0:001\u003e k","date":"2022-05-22","objectID":"/x86%E4%B8%8Ex64%E6%A0%88%E5%9B%9E%E6%BA%AF/:2:3","tags":["OS"],"title":"x86与x64栈回溯","uri":"/x86%E4%B8%8Ex64%E6%A0%88%E5%9B%9E%E6%BA%AF/"},{"categories":["Windows Kernel"],"content":"主要记录下X64VT以及实现EPT Hook时的一些关键点 ","date":"2022-03-02","objectID":"/intel-vt-x64-ept-hook%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/:0:0","tags":["Kernel","VT"],"title":"Intel VT x64 EPT Hook框架的实现","uri":"/intel-vt-x64-ept-hook%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Windows Kernel"],"content":"基本的VT开启 这部分和之前32位的没什么太大的区别，主要是在填写vmc字段时，需要额外填写如IA32_EFER，IA32E_MODE这种必须要填写的，还有像RDTSCP这种在新的win10上面系统上面做引发VMEXIT需要填写的，这种主要是为了兼容性考虑。 开启EPT的话需要在SECONDARY VM execution Control Field字段里面填写对应的enable ept字段，一般来讲不是太老的CPU都是支持的。 而在X64上多核处理的话，主要是使用KeGenericCallDpc来调用我们的VT初始化或者你需要的其他需要进行多核同步的过程，这个API就是让多个CPU同时以特殊的DPC例程执行我们的代码。 其他就是一些数据类型，寄存器的更改，换成64位的模式 ","date":"2022-03-02","objectID":"/intel-vt-x64-ept-hook%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/:0:1","tags":["Kernel","VT"],"title":"Intel VT x64 EPT Hook框架的实现","uri":"/intel-vt-x64-ept-hook%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Windows Kernel"],"content":"EPT内存管理 EPT是intel为内存虚拟化而设计的一种硬件机制，主要是是为了实现Guest对于物理内存的访问控制 因为EPT的存在，Guest对一个地址访问时，每当访问一个物理地址，都会走EPT物理地址转化的过程，这个过程和x64下的VA-\u003ePA的转换过程类似，例如访问Guest访问某个进程物理地址，首先找到CR3，此时访问CR3中的物理地址，就会触发GPA-\u003eHPA的EPT转换过程，然后访问PML4，PDE等物理地址时，都会触发一个EPT的转换，这也是VT开启EPT后性能损耗的原因之一，关于EPT各个表项的内容可以查看参考 Intel-64-ia-32–system-programming-manual-vol-3 Chapter 28.2 EPT的构建 EPT的构建，感觉就是实现一个具体的地址转换的过程，从EPTP的构建，以及其中PML4,PDPT,PDT其中各个表项的各个字段的填写 pEptState-\u003eEptPageTable = PageTable; PageTable-\u003ePML4[0].all = 0; PageTable-\u003ePML4[0].Bits.read_access = 1; PageTable-\u003ePML4[0].Bits.write_access = 1; PageTable-\u003ePML4[0].Bits.exec_access_supervisor = 1; PageTable-\u003ePML4[0].Bits.PDPTPFN = MmGetPhysicalAddress(\u0026PageTable-\u003ePML3[0]).QuadPart \u003e\u003e 12; for (int i = 0; i \u003c VMM_EPT_PML3E_COUNT; i++) { PageTable-\u003ePML3[i].all = 0; PageTable-\u003ePML3[i].Bits.read_access = 1; PageTable-\u003ePML3[i].Bits.write_access = 1; PageTable-\u003ePML3[i].Bits.exec_access_supervisor = 1; PageTable-\u003ePML3[i].Bits.PDTPFN = MmGetPhysicalAddress(\u0026PageTable-\u003ePML2[i][0]).QuadPart \u003e\u003e 12; } 上面的代码中可以看到对各个EPT表项的构建主要是对其中的对应字段进行构建填写，RWX权限位的设置，以及下一级EPT页表的地址的取值填写，例如PML4T中的每个PML4项的PFN对应一张PDPT表,所以就在PFN处填写PDPT物理地址去除属性位后的其余部分。 构建PDE以及后面的页表时，最开始我是想以4kB为基准构建的，但是后来初始化EPT一直出错（其实是其他的代码有问题），我就采取了想hvpp，gbhv等项目的采用2MB大页的方式来构建 for (int i = 0; i \u003c VMM_EPT_PML3E_COUNT; i++) { for (int j = 0; j \u003c VMM_EPT_PML2E_COUNT; j++) { PageTable-\u003ePML2[i][j].all = 0; PageTable-\u003ePML2[i][j].Bits.ExecuteAccess = 1; PageTable-\u003ePML2[i][j].Bits.ReadAccess = 1; PageTable-\u003ePML2[i][j].Bits.WriteAccess = 1; PageTable-\u003ePML2[i][j].Bits.LargePage = 1; PageTable-\u003ePML2[i][j].Bits.PhyPagePFN = (i * VMM_EPT_PML2E_COUNT) + j; SetMemMtrrInfo(PageTable-\u003ePML2[i][j], (i * VMM_EPT_PML2E_COUNT) + j); } } 也就是说到了构建PDT表的时候，其中每一项PDE的PFN不再是PTT的地址了（正常4k的构建下每个PDE指向一张PTT），而且直接指向一张物理页，采取大页的方式的话，构建整个EPT就效率有一定提高，而且后来搜了相关的东西，大页有助于减少缺页中断，TLB缓存未命中发生的次数。 MTRR MTRR的全称是Memory Type Range Registers，意思就是说一组用来指定特定内存段的内存类型的特殊寄存器,这里所说的内存类型: 同样MTRR是否支持也看CPU，一般新一点的CPU都是支持的，操作系统启动时BIOS会通过MTRR设置对应的内存访问属性，通过设置MTRR可以提高内存的访问效率，同时如果想在物理机上运行EPT这也是不可少的一个步骤,EPT在初","date":"2022-03-02","objectID":"/intel-vt-x64-ept-hook%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/:0:2","tags":["Kernel","VT"],"title":"Intel VT x64 EPT Hook框架的实现","uri":"/intel-vt-x64-ept-hook%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Windows Kernel"],"content":"SSDT 这个也没啥，就是涉及到SSDT的查找以及一些内核函数地址的查找 ULONG64* GetSSDTBase() { //先不考虑 KVAS ULONG64 lstar = __readmsr(0xC0000082); for (int i = 0; i \u003c 1024; i++) { if (*(PUCHAR)(lstar + i) == 0x4c \u0026\u0026 *(PUCHAR)(lstar + i + 2) == 0x15) { if (*(PUCHAR)(lstar + i + 7) == 0x4c \u0026\u0026 *(PUCHAR)(lstar + i + 9) == 0x1d) { if (*(PUCHAR)(lstar + i + 14) == 0xf7 \u0026\u0026 *(PUCHAR)(lstar + i + 15) == 0x43) { ULONG64 KiSystemServiceRepeat = (ULONG64)(PUCHAR)lstar + i; ULONG offset = *(ULONG*)(KiSystemServiceRepeat + 3); ULONG64 SSDTBase = KiSystemServiceRepeat + offset + 7; //7= lea r10,[nt!KeServiceDescriptorTable] return SSDTBase; } } } } return NULL; } ULONG64 GetNTAPIAddress() { int SyscallNumber = 0x002c; //NtTerminateProcess = 0x002c; ULONG64* ssdt = GetSSDTBase(); ULONG64 address = ((*(ULONG*)(*ssdt + SyscallNumber * 4)) \u003e\u003e 4) + *ssdt; return address; } 这里只是未开启内核页表隔离的情况，开启内核页表隔离lstar msr读取到的是KiSystemCall64Shadow地址，可能需要从KiSystemCall64Shadow开始往上搜了。 关于API HOOK，测试时对NtTerminateProcess做了Inline Hook的测试 Hook的步骤和通常的Hook没啥区别，在API开始的几条指令找合适的位置插入一条跳转指令，跳到我们的代码，执行完我们的代码后，跳转回当时插入的指令的下一条指令，也就是按着原路继续执行。 这里利用ETP需要将首先将原本的函数对应的物理页拷贝一份过来，然后对拷贝的EPT的页面做HOOK通过ETP Violation的处理，就可以欺骗读写行为，绕过PG等扫描，直接修改原本的物理页是不仅需要关闭写保护而且是没有意义的。 /* 12 hook bytes: mov rax,target64 JMP rax */ TargetBuffer[0] = 0x48; TargetBuffer[1] = 0xb8; *(ULONG64*)\u0026TargetBuffer[2] = TargetAddress; TargetBuffer[10] = 0xFF; TargetBuffer[11] = 0xE0; 这段代码就是构建简单的跳转指令，也可以使用PUSH，RET这种方式实现跳转 2: kd\u003e u 0xffffdd8bfd4f4f40 ffffdd8b`fd4f4f40 48b820531b3900f8ffff mov rax,offset hvcv!NtTerminateProcessHook (fffff800`391b5320) ffffdd8b`fd4f4f4a ffe0 jmp rax 这里我们临时分配一个空间，将构造好的跳转指令以及原函数需要跳过的指令（跳过是为了不破坏原有的指令，这里使用了LDE,计算跳过的指令长度），首先将跳转的hook函数的指令拷贝到原本的跳转的位置 2: kd\u003e u 0xffffdd8bf5935e50 ffffdd8b`f5935e50 4c8bdc mov r11,rsp ffffdd8b`f5935e53 49895b10 mov qword ptr [r11+10h],rbx ffffdd8b`f5935e57 49896b18 mov qword ptr [r11+18h],rbp ffffdd8b`f5935e5b 57 push rdi ffffdd8b`f5935e5c 48b84c3f6b3300f8ffff mov rax,offset nt!NtTerminateProcess+0xc (fffff800`336b3f4c) ffffdd8b`f5935e66 ffe0 jm","date":"2022-03-02","objectID":"/intel-vt-x64-ept-hook%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/:0:3","tags":["Kernel","VT"],"title":"Intel VT x64 EPT Hook框架的实现","uri":"/intel-vt-x64-ept-hook%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Hardware,Windows OS"],"content":"流程概述 Windows BIOS开机引导流程概览： 1.开机主板加电，BIOS运行 2.运行硬盘开头的MBR代码 3.MBR代码引导运行Bootmgr（也有可能引导VBR，然后VBR引导Bootmgr） 4.Bootmgr根据BCD配置，自动运行或让用户选择不同的启动项，并加载运行Winload.exe 5.Winload.exe加载ntoskrnl.exe内核模块 6.ntoskrnl.exe启动操作系统 ","date":"2022-03-02","objectID":"/windows-bios-mbr%E5%BC%95%E5%AF%BC%E5%88%86%E6%9E%90/:0:1","tags":["Kernel","OS"],"title":"Windows BIOS MBR引导分析","uri":"/windows-bios-mbr%E5%BC%95%E5%AF%BC%E5%88%86%E6%9E%90/"},{"categories":["Hardware,Windows OS"],"content":"MBR与VBR结构概览 ","date":"2022-03-02","objectID":"/windows-bios-mbr%E5%BC%95%E5%AF%BC%E5%88%86%E6%9E%90/:0:2","tags":["Kernel","OS"],"title":"Windows BIOS MBR引导分析","uri":"/windows-bios-mbr%E5%BC%95%E5%AF%BC%E5%88%86%E6%9E%90/"},{"categories":["Hardware,Windows OS"],"content":"MBR MBR主引导记录，用于引导后续运行的代码，一般用作引导bootmgr等第二阶段的引导程序 MBR一般位于每块硬盘的最开头的512个字节，也就是一个扇区的大小，其中前446个字节为引导程序，然后是64个字节的分区表，其中每个分区项为16个字节，最后是2个字节的Magic,统一为0X55,0XAA,操作系统用此Magic确定和查找引导记录，如果没有，则无法进行引导。 其中446个字节的引导程序中： 前162个字节为MBR可执行代码 163-1B2这80个字节为错误信息字符串 1B3-1BD这11字节包含2个byte 00 padding,3个字节63 7B 9A分别代表了错误信息字符串的offset，然后是4个字节的磁盘签名，然后是2个字节的padding 磁盘签名可以通过注册表查看：reg query HKEY_LOCAL_MACHINE\\SYSTEM\\MountedDevices MBR结构 //主引导记录 typedef struct _MASTER_BOOT_RECORD { CHAR bootcode[446]; //实际的引导代码 MBR_PARTITION_TABLE partitiontable[4]; //分区表 USHORT MBRMagic; // 0x55AA }MASTER_BOOT_RECORD,*PMASTER_BOOT_RECORD; //分区表项 typedef struct _MBR_PARTITION_TABLE { BYTE ActiveStatus; //活动状态 0x80=active 0x00=noactive，表示当前分区是否为活动分区，只能有一个活动分区 BYTE StartHead; WORD StartingSectCylinder; //起始扇区柱面 BYTE PARTITION_SYSTEMID; //标识ID，指示当前分区的分区类型，比如常见的有：NTFS,FAT32等等 BYTE EndHead; WORD EndingSectCylinder; DWORD RelativeSector; DWORD TotalSectors; //分区中的总扇区数 }MBR_PARTITION_TABLE,*PMBR_PARTITION_TABLE; 分析MBR代码 MBR的字节码如下图，测试环境为WIN10,21H2 IDA静态分析： seg000:7C00 seg000 segment byte public 'CODE' use16 seg000:7C00 assume cs:seg000 seg000:7C00 ;org 7C00h seg000:7C00 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing seg000:7C00 seg000:7C00 loc_7C00: ; CODE XREF: seg000:7D2A↓J seg000:7C00 33 C0 xor ax, ax seg000:7C02 8E D0 mov ss, ax ; 段地址为0 seg000:7C04 BC 00 7C mov sp, 7C00h seg000:7C07 8E C0 mov es, ax seg000:7C09 8E D8 mov ds, ax seg000:7C0B BE 00 7C mov si, 7C00h seg000:7C0E BF 00 06 mov di, 600h seg000:7C11 B9 00 02 mov cx, 200h seg000:7C14 FC cld seg000:7C15 F3 A4 rep movsb ; 从ds:si 7C00h拷贝0x200个字节到 es:di 600h处； seg000:7C15 ; 7C00h地址刚好是我们的MBR代码起始地址，大小为0x200, seg000:7C15 ; 也就是说这段代码用于备份我们的MBR代码到600h处 seg000:7C17 50 push ax seg000:7C18 68 1C 06 push 61Ch ; cs:ip = 00:61Ch; seg000:7C18 ; retf 处理器先从栈中弹出一个字到IP，再弹出一个字到CS; seg000:7C18 ; 跳转到61ch处执行；之前把MBR代码拷贝到了600h seg000:7C1B CB retf seg000:7C1C ; --------------------------------------------------------------------------- seg000:7C1C FB sti ; 代码接着从这运行 seg000:7","date":"2022-03-02","objectID":"/windows-bios-mbr%E5%BC%95%E5%AF%BC%E5%88%86%E6%9E%90/:0:3","tags":["Kernel","OS"],"title":"Windows BIOS MBR引导分析","uri":"/windows-bios-mbr%E5%BC%95%E5%AF%BC%E5%88%86%E6%9E%90/"},{"categories":["Hardware,Windows OS"],"content":"VBR VBR(Volume boot record)卷引导记录： 由于操作系统逐渐复杂，仅仅靠MBR是无法成功引导操作系统的运行，因此实际情况中，MBR则是引导活动分区的VBR,VBR读取并执行IPL(初始程序加载器)模块代码，IPL则负责解析文件系统并加载Bootmgr模块，引导操作系统初始化。 VBR结构 typedef struct _BOOTSTRAP_CODE { BYTE Bootcode[426]; //引导扇区代码，JMP后会跳转到这 WORD bootSignature; //0x55AA }BOOTSTRAP_CODE,*PBOOTSTRAP_CODE; typedef struct _BIOS_PARAMETER_BLOCK { WORD BytesPerSector; BYTE SectorsPerCluster; WORD ReservedSectors; CHAR Reserved1[5]; BYTE MediaId; CHAR Reserved2[2]; WORD SectorsPerTrack; WORD NumberOfHeader; DWORD HiddenSectors; CHAR Reserved3[8]; QWORD TotalSectorsNumber; QWORD LogicalClusterMFT; QWORD LogicalClusterMFTMirror; DWORD ClustersPerFileRecSegment; DWORD ClustersPerIndexBlock; QWORD SerialNumber; DWORD Checksum; }BIOS_PARAMETER_BLOCK, * PBIOS_PARAMETER_BLOCK; typedef struct _VOLUME_BOOT_RECORD { WORD JMP; BYTE NOP; CHAR OEM_NAME[8]; // OEM NAME BIOS_PARAMETER_BLOCK BPB; //BIOS参数块 BOOTSTRAP_CODE BootStrap; }VOLUME_BOOT_RECORD,*PVOLUME_BOOT_RECORD; 分析VBR代码 VBR代码一共占用一个扇区512个字节 前两个字节为一个JMP指令，用于跳转到VBR主引导代码段 第三个字节 90为一个NOP OEM_ID占用8个字节，这个跟磁盘格式有关NTFS基本都是4E 54 46 53 20 20 20 20，如果是FAT32等别的，值会不一样 然后是72个字节的BPB块 0x54h-0x189h 则为实际的VBR引导代码 然后是一些00字节padding 8A 01 A7 01 BF 01 这些分别是错误字符串的OFFSET，例如018a则是A disk read error….. 最后两个字节0x55AA IDA静态分析： seg000:0000 ; Segment type: Pure code seg000:0000 seg000 segment byte public 'CODE' use16 seg000:0000 assume cs:seg000 seg000:0000 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing seg000:0000 EB 52 jmp short loc_54 ; 调整ss段寄存器，关闭中断 seg000:0000 ; --------------------------------------------------------------------------- seg000:0002 90 db 90h seg000:0003 4E db 4Eh ; N seg000:0004 54 46 53 20 20 20 20 00 aTfs db 'TFS ',0 ; DATA XREF: seg000:00F8↓o seg000:0004 ; seg000:00A9↓r seg000:000C 02 db 2 seg000:000D 08 00 00 00 00 00 00 00+byte_D db 8, 7 dup(0), 0F8h, 2 dup(0), 3Fh, 0, 0FFh, 2 dup(0) seg000:000D F8 00 00 3F 00 FF 00 00+ ; DATA XREF: sub_11D+20↓r seg000:000D 08 00 00 00 00 00 00 80+ ; seg000:00AF↓w ... seg000:000D 00 80 00 FF 8F 0","date":"2022-03-02","objectID":"/windows-bios-mbr%E5%BC%95%E5%AF%BC%E5%88%86%E6%9E%90/:0:4","tags":["Kernel","OS"],"title":"Windows BIOS MBR引导分析","uri":"/windows-bios-mbr%E5%BC%95%E5%AF%BC%E5%88%86%E6%9E%90/"},{"categories":["Hardware,Windows OS"],"content":"MBR/VBR Bochs 动态调试 我这里使用了Bochs+IDA的方式，安装Bochs Windows版，Bochsrc内容如下: megs: 256 romimage:file=\"..\\BIOS-bochs-latest\" vgaromimage:file=\"..\\VGABIOS-lgpl-latest\" ata0-master: type=disk, path=\"..\\c.img\", mode=flat, cylinders=20, heads=16, spt=63 boot: disk 镜像制作过程，利用Bochs自带的bximage制作即可，选择1，然后一路回车即可。 之后用二进制编辑器如010editor，讲自己系统硬盘的MBR/VBR代码拷贝到制作好的img镜像即可，拷贝的地址偏移均不变。 IDA中在主菜单中debugger选项，选择本地bochs调试，选择上面新建好的Bochsrc文件即可。 可能会遇到cfg文件报错，只需要在IDA文件夹下的cfg/dbg_bochs.cfg中编辑BOCHSDBG的路径即可。 ","date":"2022-03-02","objectID":"/windows-bios-mbr%E5%BC%95%E5%AF%BC%E5%88%86%E6%9E%90/:0:5","tags":["Kernel","OS"],"title":"Windows BIOS MBR引导分析","uri":"/windows-bios-mbr%E5%BC%95%E5%AF%BC%E5%88%86%E6%9E%90/"},{"categories":["Hardware,Windows OS"],"content":"总结 综上结果，可以简单总结一下windows引导过程： 加载MBR，MBR将自己备份到0x600H处，并更改IP为61CH开始执行代码 循环4次，在分区表中通过匹配活动分区标志，找到活动分区 通过int13中断，从0x800扇区处，读取一个扇区的代码大小，也就是读取512bytes的VBR，写入0x7C00H处 做一些端口读取和写入检测，然后代码进入VBR执行，MBR执行过程中，每次涉及到检测，只要错误，就会通过INT10打印错误信息，并停止运行代码 VBR代码执行，JMP跳转，并关闭中断，调整段寄存器 验证OEMID是否为NTFS 通过读取BPB结构体中HiddeSectors字段，加1得到IPL代码所在的扇区数，并读取0x2000个字节的IPL代码 跳转到IPL代码处，控制权交给IPL，开始后续的加载Bootmgr的过程 ","date":"2022-03-02","objectID":"/windows-bios-mbr%E5%BC%95%E5%AF%BC%E5%88%86%E6%9E%90/:0:6","tags":["Kernel","OS"],"title":"Windows BIOS MBR引导分析","uri":"/windows-bios-mbr%E5%BC%95%E5%AF%BC%E5%88%86%E6%9E%90/"},{"categories":["Windows OS"],"content":"寄存器 首先是寄存器数值的宽度，除去标志寄存器和段寄存器(段寄存器长度均为96位，其中有16位的可见部分和80位的不可见部分)外，均为8个字节64位宽度，在32位平台的基础上，增加了R8~R15共8个寄存器 易变寄存器:RAX,RCX,RDX,R8-R11 非易变寄存器：RBP,RBX,RSI,RDI,R12-R15 ","date":"2021-08-21","objectID":"/x64%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/:0:1","tags":["OS"],"title":"x64的一些特性","uri":"/x64%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/"},{"categories":["Windows OS"],"content":"FS与GS 32位的操作系统中，FS寄存器在3环执向TEB结构体，0环指向KPCR结构体，在X64中，则是使用GS寄存器 微软提供了IA32_FS_BASE(0xC0000100)和IA32_GS_BASE MSR(0xC0000101)寄存器用于获取Base,因为如果用段描述的方式去获取Base的话，在64位的段描述符中，是没法再放入64位的地址 FS则继续给Wow64提供服务，也就是32位的应用程序 ","date":"2021-08-21","objectID":"/x64%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/:0:2","tags":["OS"],"title":"x64的一些特性","uri":"/x64%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/"},{"categories":["Windows OS"],"content":"内存布局与内存模型 x64下内存分配，理论可以使用2^64次大小的内存空间，但是实际操作系统设计时只用了其中的48位，x64采用了9-9-9-9-12分页，也就是PML4T分页，按照32位操作系统非PAE分页的套路，也即10-10-12分页，PDE-PTE-offset，总的内存1024x1024x4k=4Gb，其中用户和内核各使用了2GB,在x64下理论上支持，512x512x512x512x4k=256Tb，实际上windows支持16TB左右的空间 其中: 用户空间:0x00000000~00000000 — 0x000007fff~ffffffff 内核空间:0xfffff800~00000000 — 0xffffffff~ffffffff IA-32架构下主要内存模型为:Basic Flat Module(基本的平坦模型)，Protect Flat Module(受保护的平坦模式)，Multi-Segment Module(分段内存模型) Basic Flat Module(基本的平坦模型) 最为简单的一种模型，操作系统和应用程序可以访问不受限制的内存空间，没有任何的分段机制，根据inter开发手册所说，一个最简单的平坦模型，至少建立两个段描述符，一个数据，一个代码，分别指向了数据段，代码段，但是都被映射到基址为0，限长为4gb的内存空间，即便访问的地址超过了实际物理内存的最大地址，也不会报错 Protect Flat Module(受保护的平坦模式) 主要是在基本的平坦模型中，提供了内存访问保护，超出界限后会出发保护异常，同样有了特权级机制的段权限分配，也即用户模式和内核模式，这些段的基址都是从0开始，也就是说这些段在内存空间上来说都是重叠的，逻辑上划分为不同的用途 Multi-Segment Module(分段内存模型) 相较于前两种，稍稍复杂一点，这种对于不同用途的段在内存划分上也分离开来，实现真正的内存分段，对不同段，如代码段，数据段，内存访问采用seg base+offset的形式，采用了强制的硬件级的保护机制，每个应用程序可以有自己的私有段，也可以和其他程序共享，同样的，段权限检查和访问控制机制，都可以阻止如内存越界等非法访问操作 在x64中，根据inter开发手册: In 64-bit mode, segmentation is generally (but not completely) disabled, creating a flat 64-bit linear-address space. The processor treats the segment base of CS, DS, ES, SS as zero, creating a linear address that is equal to the effective address. The FS and GS segments are exceptions. These segment registers (which hold the segment base) can be used as additional base registers in linear address calculations. They facilitate addressing local data and certain operating system data structures. CS, DS, ES, SS的段基址全部为0,base全部为0，但是FS和GS除外，它们的base可以通过前面说过的MSR寄存器获得 x64中，中断描述符和TSS段描述符均变为了128位，代码段和数据段描述符依然是64位 ","date":"2021-08-21","objectID":"/x64%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/:0:3","tags":["OS"],"title":"x64的一些特性","uri":"/x64%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/"},{"categories":["Windows OS"],"content":"调用约定 X64的调用约定使用4寄存器的fast-call约定，整数参数在寄存器RCX,RDX,R8,R9,尽管使用了寄存器传参，但是系统还是会分配堆栈空间，而且堆栈平衡是由调用者完成 VOID x64_go(int a, int b, int c, int d) { printf(\"a:%d\\n\", a); printf(\"b:%d\\n\", b); printf(\"c:%d\\n\", c); printf(\"d:%d\\n\", d); } VOID main() { int a = 1; int b = 2; int c = 3; int d = 4; x64_go(a, b, c, d); printf(\"over\\n\"); system(\"pause\"); } 这段测试代码中，调用函数时所对应的汇编是这样的 mov dword ptr [a],1 mov dword ptr [b],2 mov dword ptr [c],3 mov dword ptr [d],4 mov r9d,dword ptr [d] mov r8d,dword ptr [c] mov edx,dword ptr [b] mov ecx,dword ptr [a] call x64_go 可以看到当我们的参数长度不超过4个字节的时候，分别使用32位的寄存器进行传参，这个是编译器做的处理，长度足够存储数据的情况下，优先使用32位寄存器，因为操作64位寄存器(如MOV指令)的指令占4个字节，多一个48前缀指令，说明操作数是64位的，而32位寄存器只需要3个字节的指令长度 然后是堆栈分配的问题，调用者在调用子函数之前，根据函数参数的总长度，分配堆栈空间，这个堆栈空间至少要能容纳Regs*8，也就是所需保存的寄存器的总长度，如果有局部变量，则需要额外分配，并且要确保，在进入函数的时候，RSP要0x10对齐，这个堆栈空间用来进入子函数后，保存这些寄存器，以免后续可能会用到这些寄存器，从而改变导致后续出现异常 如果我想调用一个4个参数的函数，大概应该就是这样 VOID x64_go2(int a, int b, int c, int d) { printf(\"a:%d\\n\", a); printf(\"b:%d\\n\", b); printf(\"c:%d\\n\", c); printf(\"d:%d\\n\", d); } test1 proc mov rcx,1 mov rdx,2 mov r8,3 mov r9,4 sub rsp,30h call x64_go2 add rsp,30h ret test1 endp 栈帧 x86函数下，一般以标志性的 push ebp,mov ebp,esp,sub esp,xxxx 三连起始,其中通过ebp被叫为帧指针，esp为栈指针，前者对应栈底，后者对应栈顶，而一般进行如局部变量访问，参数访问等，都是通过ebp来找的，例如一般情况下ebp+4是返回地址，ebp+8是第一个参数，函数堆栈图大概如下这样，从上到下地址逐渐减小 x64下使用RSP即为栈指针也为帧指针，所有的操作以RSP为基准进行，类似pop和push等可以更改RSP的操作，一般都在函数开始和尾部进行，RSP在同一个函数体内，保持不变 VOID x64_go(int a, int b, int c) { printf(\"a:%d\\n\", a); printf(\"b:%d\\n\", b); printf(\"c:%d\\n\", c); } VOID main() { int a = 1; int b = 2; int c = 3; x64_go(a, b, c); } 上面的代码，对应如下的一个过程: 至于堆栈布局，其实和x86的是类似的 VOID x64_go(ULONG64 a, ULONG64 b, ULONG64 c) { int x = 111; printf(\"a:%llx\\n\", a); printf(\"b:%llx\\n\", b); printf(\"c:%llx\\n\", c); } VOID main() { ULONG64 a = 1; ULONG64 b = 2; ULONG64 c = 3; ULONG64 d = 4; x64_go(a, b, c); system(\"pause\"); } 把核心的汇编代码抠出来，用来做堆栈结构图 sub rsp, 48h mov dword ptr [rsp+30h], 1 mov dword ptr [rsp+28h], 2 mov dword ptr [rsp+20h], 3 mov dword ptr [rsp+38h], 4 mov r8d, [rsp+20h] mov rdx, [rsp+28h] mov rcx","date":"2021-08-21","objectID":"/x64%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/:0:4","tags":["OS"],"title":"x64的一些特性","uri":"/x64%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/"},{"categories":["Windows OS"],"content":"X64分页机制 x64分页和32位系统下的PAE分页分页是相似的，在原有的3级页映射的基础上，多了PML4T(4级页映射表)，因为x64使用了48位的虚拟地址，根据地址转换过程中虚拟地址的对应关系，也叫做9-9-9-9-12分页 以虚拟地址0x13fb7ff98为例，此处存了一个自定义字符串,因为实际使用了48位虚拟地址，所以最终拆分的地址为0x00013fb7ff98 拆分后得到9-9-9-9-12结构为 0000 0000 0 0 0000 0010 0 0x4 1111 1110 1 0x1fd 1011 1111 1 0x17f 1111 1001 1000 0xf98 在手动查找物理地址时，要注意高于48位以及低12位清0，这些是属性和保留位，只有中间的部分12-48位为PFN页帧，除了最后的12位页面偏移，其他的都要乘以8，因为每个PDE，PTE等页目录项都是8个字节为单位 0: kd\u003e !dq 130fd1000 #130fd1000 03000001`26616867 00000000`00000000 #130fd1010 00000000`00000000 00000000`00000000 #130fd1020 00000000`00000000 00000000`00000000 #130fd1030 00000000`00000000 00000000`00000000 #130fd1040 00000000`00000000 00000000`00000000 #130fd1050 00000000`00000000 00000000`00000000 #130fd1060 00000000`00000000 00000000`00000000 #130fd1070 00000000`00000000 00800001`2f312867 0: kd\u003e !dq 00000001`26616000+0x4*8 #126616020 03100001`24a17867 00000000`00000000 #126616030 00000000`00000000 00000000`00000000 #126616040 00000000`00000000 00000000`00000000 #126616050 00000000`00000000 00000000`00000000 #126616060 00000000`00000000 00000000`00000000 #126616070 00000000`00000000 00000000`00000000 #126616080 00000000`00000000 00000000`00000000 #126616090 00000000`00000000 00000000`00000000 0: kd\u003e !dq 00000001`24a17000+0x1fd*8 #124a17fe8 05200001`24818867 00000000`00000000 #124a17ff8 00000000`00000000 006f004c`00740076 #124a18008 00650052`002e0067 00720075`006f0073 #124a18018 00220073`00650063 00720065`00760020 #124a18028 006e006f`00690073 002e0036`0022003d #124a18038 00360037`002e0031 0032002e`00310030 #124a18048 00320037`00300033 00720070`00200022 #124a18058 00730065`0063006f 00410072`006f0073 0: kd\u003e !dq 00000001`24818000+0x17f*8 #124818bf8 9e100000`bdfba005 b2300000`71cf0005 #124818c08 b2400000`73af1005 95600001`2e45d005 #124818c18 a0000001`308d6005 b2500000`71df2005 #124818c28 b2600001`064f3005 b2700000`734f4005 #124818c38 b2800001`2f2f5005 b2900000`70bf6005 #124818c48 b2a00000`b8ff7005 b2b00000`b9ff8005 #124818c58 b2c00001`227f9005 b2d00001`2defa005 #124818c68 b2e","date":"2021-08-21","objectID":"/x64%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/:0:5","tags":["OS"],"title":"x64的一些特性","uri":"/x64%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/"},{"categories":["Windows Kernel"],"content":" Intel VT-x是Intel芯片用于支持硬件虚拟化的一种技术，个人理解是在传统的操作系统之上，创建专用于虚拟化开发者的特权级环境，这种权限甚至高于操作系统的环境，也就是常说的Hypervisor层，同样的，新的环境也会引入一些新的特权指令等新的功能。在设计架构上和SVM类似，分为VMM和VMGUEST两种角色，分别处于VMX-ROOT和VMX-NO ROOT模式下 对于虚拟机来说，Hypervisor是完全透明的，当Guest客户机发生vmexit事件后会陷入到Hypervisor，此时控制权完全交与Hypervisor，而Hypervisor同样可以通过vmlaunch运行虚拟机，或者在处理完vmexit事件后，通过vmresume指令，继续运行虚拟机 ","date":"2021-06-02","objectID":"/intel-vt-x-mini-vt-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/:0:0","tags":["Kernel","VT"],"title":"Intel VT-x mini VT 框架的实现","uri":"/intel-vt-x-mini-vt-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Windows Kernel"],"content":"VT框架实现流程 本代码用于学习研究，运行于32位操作系统之上，在代码实现VT的时候，主要是需要遵循Intel开发手册的标准，我这里实现的时候，大概是以下的流程: 判断当前CPU是否支持VT技术，通过执行cpuid指令，获取返回信息并判断对应的标志位，这是硬件层面的要求 读取MSR_IA32_FEATURE_CONTROL MSR寄存器对应标志位，用于判断在BIOS配置中是否开启了VT 检查并设置CR4 VMXE标志位 分配4K对齐的内存，用于vmx操作，这块区域按照白皮书的定义一般叫做VMXON region 初始化VMXON region区域，主要是写入一个VMCS版本号，这个版本号通过读取 IA32_MSR_VMX_BASIC MSR寄存器获得 执行VMXON,并检查EFLAGE.CF位是否置0，判断是否执行成功 分配4K对齐的内存，用于逻辑处理器也即虚拟机的操作区域，叫做VMCS region 调用vmclear指令，将VMCS区域设置为清除状态，也即区域初始化 调用vmptrld指令，激活VMCS 为host以及guest分配内存空间 填充VMCS区域，这是最重要也是最复杂的一步 通过vmlaunch运行虚拟机 ","date":"2021-06-02","objectID":"/intel-vt-x-mini-vt-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/:0:1","tags":["Kernel","VT"],"title":"Intel VT-x mini VT 框架的实现","uri":"/intel-vt-x-mini-vt-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Windows Kernel"],"content":"代码部分 这个代码写的也是一波三折，蓝屏N次，也是各种坑，虽然可以有参考代码，但实际上有很多因素，遇到比如像保存现场代码的优化，多核处理等等诸多问题 首先是开启VT的前期，检测阶段，首先就是通过CPUID指令，这个指令执行前，需要将EAX寄存器置为1，返回值会存在ECX寄存器中，这里CPUID置1是Intel的要求，如果EAX中是其他值，返回的信息也是不同的，只是在这里用作CPU VTZ支持检测，EAX需要置1 get_cpuid_info proc,_para:dword pushad mov eax,1H cpuid mov esi,_para mov [esi],ecx popad ret get_cpuid_info endp 然后是读取IA32_FEATURE_CONTROL MSR寄存器,如果在bios启用VT则bit1，bit2或者两者都必须为1，bit1和bit2主要用于设置是否处于SMX Mode（安全扩展模式）下，这里一般检测bit2就可以了 ULONG64 msr = __readmsr(MSR_IA32_FEATURE_CONTROL); if (!(msr \u0026 4)) //4.VT 指令是否被锁定 { DbgPrint(\"MSR_IA32_FEATURE_CONTROL VMXON Locked \\n\"); return STATUS_UNSUCCESSFUL; } 检测并设置CR4.VMXE也就是bit13位，在VMXON和VMXOFF之间不许再修改此位 set_cr4(X86_CR4_VMXE); //3.设置CR4.VMXE cr4 = get_cr4(); if ((cr4 \u0026 X86_CR4_VMXE) != X86_CR4_VMXE) { DbgPrint(\"CR4_VMXE set Error \\n\"); return STATUS_UNSUCCESSFUL; } 分配VMXON Region区域，读取MSR寄存器，获取VMCS标识并用其初始化VMXON Region，白皮书中说设置前31位，这里需要注意分配非分页内存，然后就可以通过VMXON进入虚拟机模式了，这里首先要获取VMXON Region区域的物理地址，作为参数传递给VMXON，执行完VMXON后需要验证Eflags寄存器的CF位和ZF是否为0，0表示开启成功(参考 Intel-64-ia-32–system-programming-manual-vol-3 Chapter 24.1) vmx_on proc,LowPart:dword,HighPart:dword push HighPart push LowPart vmxon qword ptr [esp] add esp,8 ret vmx_on endp vmx_basic_msr = __readmsr(MSR_IA32_VMX_BASIC); //获取vmcs identifier VMX_Region = ExAllocatePoolWithTag(NonPagedPool, 4096, 'vmx'); RtlZeroMemory(VMX_Region, 4096); *(ULONG*)VMX_Region = (vmx_basic_msr \u0026 0x7ffffff); VMXONRegion_PA = MmGetPhysicalAddress(VMX_Region); vmx_on(VMXONRegion_PA.LowPart,VMXONRegion_PA.HighPart); 前期检测的过程基本完了，接下来就是分配内存了，首先是分配VMCS Region,这块区域是最核心的，可以看为是虚拟化逻辑处理器做各种操作所需要的内存空间，VMCS Region中存在各种域，是需要手动指定填充的，同样需要为Host分配一块内存，用于guest发生vmexit回到host所需要的内存空间，同样分配内存4k对齐以及非分页，在驱动卸载时要释放这几块内存区域，在VMCS Region分配完后，需要调用vmclear以及vmptrld指令，用于初始化和激活VMCS Region VMXCS_Region = ExAllocatePoolWithTag(NonPagedPool, 4096,'vmcs'); DbgPrint(\"VMXCS_Region: %x\\n\", VMXCS_Region); RtlZeroMemory(VMXCS_Region, 4096); vmx_basic_msr = __readmsr(MSR_IA32_VMX_BASIC); *(ULONG*)VMXCS_Region = (vmx_basic_msr \u0026 0x7ffffff); VMCSRegion","date":"2021-06-02","objectID":"/intel-vt-x-mini-vt-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/:0:2","tags":["Kernel","VT"],"title":"Intel VT-x mini VT 框架的实现","uri":"/intel-vt-x-mini-vt-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Windows Kernel"],"content":"扩展 1.VMEXIT导致GDT Limit发生改变，使用ARK工具查看GDT相关信息时出发BSoD 这个是在看zhouhe的VT教程看到的，至于原因，白皮书说,VMEXIT时会加载一些host的CR寄存器,msr寄存器,加载GDTR和IDTR时，limit会从3ff变为ffff: 在驱动加载,开启VT前可以保存一份GDTR，驱动卸载，关闭VT后恢复即可 2.VM第一次初始化运行，驱动继续执行的问题,就是说我们运行vmlaunch之后，进入虚拟机里，后续的驱动代码时不会执行的，卡死的状态，所以我们要构造一个上下文环境，在vmlaunch之后，我们的驱动代码可以正常执行完毕： VTenable_before(); StartVMXCS(); VTenable_after(); 在VMCS初始化填写前后，构造两个函数，我这里汇编实现： VTenable_before proc cli mov DriverEAX,eax mov DriverECX,ecx mov DriverEDX,edx mov DriverEBX,ebx mov DriverESP,esp mov DriverEBP,ebp mov DriverESI,esi mov DriverEDI,edi pushfd pop DriverEFL sti ret VTenable_before endp 之前保存现场，之后恢复现场，第一次进入VM时，就会跳转到我们的vmx_GuestReturn代码执行，而这个vmx_GuestReturn功能就是调用VTenable_after()，确保驱动正常执行完毕 vmx_vmwrite(VMCS_GUSTAREA_RIP, (ULONG)vmx_GuestReturn); 3.多核问题 看雪小宝来了说过这个问题，就是说我们VT的开启，肯定是以CPU为基准的，单核那就在这个核上开启VT就行，但如果是多核的情况下，不可能仅在个别核上开启VT，那必然时蓝屏啊，所以需要扩展至多核兼容，比如分配各种内存时，需要每个核都分配，同样在执行VT代码的时候，每个核都要执行一边才行 for (int i = 0; i \u003c KeNumberProcessors; i++) { KeSetSystemAffinityThread((KAFFINITY)(1 \u003c\u003c i)); VT_Enable(); KeRevertToUserAffinityThread(); DbgPrint(\"stop vt on cpu [%d]...\\n\", i); } 具体API的使用以及用途,参考MSDN文档即可 Code: https://github.com/Jhinxs/x32_VT Reference: https://github.com/zzhouhe/VT_Learn/tree/master/MinimalVT https://bbs.pediy.com/thread-211973.htm https://github.com/haidragon/newbluepill «new blue pill:深入理解硬件虚拟机» «Intel 64-ia-32–system-programming-manual-vol-3» ","date":"2021-06-02","objectID":"/intel-vt-x-mini-vt-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/:0:3","tags":["Kernel","VT"],"title":"Intel VT-x mini VT 框架的实现","uri":"/intel-vt-x-mini-vt-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/"}]