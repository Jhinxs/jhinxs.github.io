<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Jhin&#39;s Story</title>
        <link>https://jhinxs.com/</link>
        <description>Jhinxs</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>jhinxs story</copyright><lastBuildDate>Fri, 22 Jul 2022 18:17:35 &#43;0800</lastBuildDate>
            <atom:link href="https://jhinxs.com/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>Ollvm Windows下编译及VS集成</title>
    <link>https://jhinxs.com/ollvm-windows%E4%B8%8B%E7%BC%96%E8%AF%91%E5%8F%8Avs%E9%9B%86%E6%88%90/</link>
    <pubDate>Fri, 22 Jul 2022 18:17:35 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jhinxs.com/ollvm-windows%E4%B8%8B%E7%BC%96%E8%AF%91%E5%8F%8Avs%E9%9B%86%E6%88%90/</guid>
    <description><![CDATA[之前用的Ollvm基于LLVM4的实在在是太老了，看到了几个新一点的项目就拿来编译瞅瞅，在Windows下编译的过程过于坎坷，一共编译成功了两个项目，这里分别记录一下，以供查查 https://github.com/bluesadi/Pluto-Obfuscator
https://github.com/lemon4ex/obfuscator/tree/llvm-13.0
*注：
（1）都需要安装ninja编译工具：https://github.com/ninja-build/ninja/releases/tag/v1.10.2 （ninja编译速度快）
（2）要在VS中安装Clang编译集成工具

（3）在项目工程文件夹中，新建Directory.build.props 文件，内容如下，路径为你的即可：
1 2 3 4 5 6  &lt;Project&gt; &lt;PropertyGroup&gt; &lt;LLVMInstallDir&gt;D:\Pluto-Obfuscator\build&lt;/LLVMInstallDir&gt; &lt;LLVMToolsVersion&gt;12.0.1&lt;/LLVMToolsVersion&gt; &lt;/PropertyGroup&gt; &lt;/Project&gt;   Ollvm13 项目地址：https://github.com/lemon4ex/obfuscator/tree/llvm-13.0
这个项目编译的过程:
编译命令 1 2 3 4 5 6 7 8  进入VS开发者命令行建议管理员，建议关闭杀软 G:\VisualStudio2019\VisualStudio2019\VC\Auxiliary\Build\vcvarsall.bat x64 cd obfuscator-llvm-13.0 mkdir build cd build cmake -G &#34;Ninja&#34; -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_NEW_PASS_MANAGER=OFF -DLLVM_INCLUDE_TESTS=OFF .. ninja 编译完后再bin目录下看到生成的clang等exe表示成功，编译过程中产生的warning可忽略   混淆命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  控制流扁平化 这个模式主要是把一些if-else语句，嵌套成do-while语句 -mllvm -fla：激活控制流扁平化 -mllvm -split：激活基本块分割。在一起使用时改善展平。 -mllvm -split_num=3：如果激活了传递，则在每个基本块上应用3次。默认值：1 指令替换 这个模式主要用功能上等效但更复杂的指令序列替换标准二元运算符(+ , – , &amp; , | 和 ^) -mllvm -sub：激活指令替换 -mllvm -sub_loop=3：如果激活了传递，则在函数上应用3次。默认值：1 虚假控制流程 这个模式主要嵌套几层判断逻辑，一个简单的运算都会在外面包几层if-else，所以这个模式加上编译速度会慢很多因为要做几层假的逻辑包裹真正有用的代码。 另外说一下这个模式编译的时候要浪费相当长时间包哪几层不是闹得！ -mllvm -bcf：激活虚假控制流程 -mllvm -bcf_loop=3：如果激活了传递，则在函数上应用3次。默认值：1 -mllvm -bcf_prob=40：如果激活了传递，基本块将以40％的概率进行模糊处理。默认值：30 ##### https://heroims.]]></description>
</item><item>
    <title>x86与x64栈回溯</title>
    <link>https://jhinxs.com/x86%E4%B8%8Ex64%E6%A0%88%E5%9B%9E%E6%BA%AF/</link>
    <pubDate>Sun, 22 May 2022 09:32:15 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jhinxs.com/x86%E4%B8%8Ex64%E6%A0%88%E5%9B%9E%E6%BA%AF/</guid>
    <description><![CDATA[x86 Call Stack 在x86下，一般函数的调用栈帧的结构大概如下:

在管理栈空间中，最主要的两个寄存器分别为EBP以及ESP,EBP表示为当前函数栈的开始，也就是栈底，而ESP则用于提升栈空间，表示为栈顶。
1 2 3 4 5 6 7 8 9 10 11  void add() { printf(&#34;test&#34;); } void test() { int c = 1; int b = 2; add(); }   反汇编上述代码我们大致可以看到类似如下的汇编语句:
1 2 3 4 5 6 7 8 9 10  push ebp mov ebp,esp sub esp,xxxH mov dword ptr [ebp-4h],1 mov dword ptr [ebp-8h],2 call add add esp,xxxH mov esp,ebp pop ebp ret   结合上图不难看出，在x86下，通过EBP可以寻址当前函数体内的局部变量，函数参数，也可以找到函数返回地址，父函数的栈空间，例如：EBP-XXXH 通常表示当前函数内的局部变量，EBP+4 的位置则是返回地址，EBP+8 的位置可能是函数的参数。如此一来，不难看出通过EBP加正数偏移可以引用父函数的地址空间，加负数偏移可以引用当前函数的地址空间。]]></description>
</item><item>
    <title>Intel VT x64 EPT Hook框架的实现</title>
    <link>https://jhinxs.com/intel-vt-x64-ept-hook%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
    <pubDate>Wed, 02 Mar 2022 15:22:06 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jhinxs.com/intel-vt-x64-ept-hook%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
    <description><![CDATA[主要记录下X64VT以及实现EPT Hook时的一些关键点
基本的VT开启 这部分和之前32位的没什么太大的区别，主要是在填写vmc字段时，需要额外填写如IA32_EFER，IA32E_MODE这种必须要填写的，还有像RDTSCP这种在新的win10上面系统上面做引发VMEXIT需要填写的，这种主要是为了兼容性考虑。 开启EPT的话需要在SECONDARY VM execution Control Field字段里面填写对应的enable ept字段，一般来讲不是太老的CPU都是支持的。
而在X64上多核处理的话，主要是使用KeGenericCallDpc来调用我们的VT初始化或者你需要的其他需要进行多核同步的过程，这个API就是让多个CPU同时以特殊的DPC例程执行我们的代码。
其他就是一些数据类型，寄存器的更改，换成64位的模式
EPT内存管理 EPT是intel为内存虚拟化而设计的一种硬件机制，主要是是为了实现Guest对于物理内存的访问控制

因为EPT的存在，Guest对一个地址访问时，每当访问一个物理地址，都会走EPT物理地址转化的过程，这个过程和x64下的VA-&gt;PA的转换过程类似，例如访问Guest访问某个进程物理地址，首先找到CR3，此时访问CR3中的物理地址，就会触发GPA-&gt;HPA的EPT转换过程，然后访问PML4，PDE等物理地址时，都会触发一个EPT的转换，这也是VT开启EPT后性能损耗的原因之一，关于EPT各个表项的内容可以查看参考 Intel-64-ia-32&ndash;system-programming-manual-vol-3 Chapter 28.2
EPT的构建 EPT的构建，感觉就是实现一个具体的地址转换的过程，从EPTP的构建，以及其中PML4,PDPT,PDT其中各个表项的各个字段的填写
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  pEptState-&gt;EptPageTable = PageTable; PageTable-&gt;PML4[0].all = 0; PageTable-&gt;PML4[0].Bits.read_access = 1; PageTable-&gt;PML4[0].Bits.write_access = 1; PageTable-&gt;PML4[0].Bits.exec_access_supervisor = 1; PageTable-&gt;PML4[0].Bits.PDPTPFN = MmGetPhysicalAddress(&amp;PageTable-&gt;PML3[0]).QuadPart &gt;&gt; 12; for (int i = 0; i &lt; VMM_EPT_PML3E_COUNT; i++) { PageTable-&gt;PML3[i].all = 0; PageTable-&gt;PML3[i].]]></description>
</item><item>
    <title>x64的一些特性</title>
    <link>https://jhinxs.com/x64%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/</link>
    <pubDate>Sat, 21 Aug 2021 12:37:55 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jhinxs.com/x64%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/</guid>
    <description><![CDATA[寄存器 首先是寄存器数值的宽度，除去标志寄存器和段寄存器(段寄存器长度均为96位，其中有16位的可见部分和80位的不可见部分)外，均为8个字节64位宽度，在32位平台的基础上，增加了R8~R15共8个寄存器

 易变寄存器:RAX,RCX,RDX,R8-R11 非易变寄存器：RBP,RBX,RSI,RDI,R12-R15  FS与GS 32位的操作系统中，FS寄存器在3环执向TEB结构体，0环指向KPCR结构体，在X64中，则是使用GS寄存器

微软提供了IA32_FS_BASE(0xC0000100)和IA32_GS_BASE MSR(0xC0000101)寄存器用于获取Base,因为如果用段描述的方式去获取Base的话，在64位的段描述符中，是没法再放入64位的地址

FS则继续给Wow64提供服务，也就是32位的应用程序
内存布局与内存模型 x64下内存分配，理论可以使用2^64次大小的内存空间，但是实际操作系统设计时只用了其中的48位，x64采用了9-9-9-9-12分页，也就是PML4T分页，按照32位操作系统非PAE分页的套路，也即10-10-12分页，PDE-PTE-offset，总的内存1024x1024x4k=4Gb，其中用户和内核各使用了2GB,在x64下理论上支持，512x512x512x512x4k=256Tb，实际上windows支持16TB左右的空间 其中:
 用户空间:0x00000000~00000000 &mdash; 0x000007fff~ffffffff 内核空间:0xfffff800~00000000 &mdash; 0xffffffff~ffffffff  IA-32架构下主要内存模型为:Basic Flat Module(基本的平坦模型)，Protect Flat Module(受保护的平坦模式)，Multi-Segment Module(分段内存模型)
  Basic Flat Module(基本的平坦模型)
最为简单的一种模型，操作系统和应用程序可以访问不受限制的内存空间，没有任何的分段机制，根据inter开发手册所说，一个最简单的平坦模型，至少建立两个段描述符，一个数据，一个代码，分别指向了数据段，代码段，但是都被映射到基址为0，限长为4gb的内存空间，即便访问的地址超过了实际物理内存的最大地址，也不会报错
  
  Protect Flat Module(受保护的平坦模式)
主要是在基本的平坦模型中，提供了内存访问保护，超出界限后会出发保护异常，同样有了特权级机制的段权限分配，也即用户模式和内核模式，这些段的基址都是从0开始，也就是说这些段在内存空间上来说都是重叠的，逻辑上划分为不同的用途
  
  Multi-Segment Module(分段内存模型)
相较于前两种，稍稍复杂一点，这种对于不同用途的段在内存划分上也分离开来，实现真正的内存分段，对不同段，如代码段，数据段，内存访问采用seg base+offset的形式，采用了强制的硬件级的保护机制，每个应用程序可以有自己的私有段，也可以和其他程序共享，同样的，段权限检查和访问控制机制，都可以阻止如内存越界等非法访问操作
  
在x64中，根据inter开发手册:
 In 64-bit mode, segmentation is generally (but not completely) disabled, creating a flat 64-bit linear-address space.]]></description>
</item><item>
    <title>Intel VT-x mini VT 框架的实现</title>
    <link>https://jhinxs.com/intel-vt-x-mini-vt-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
    <pubDate>Wed, 02 Jun 2021 12:37:55 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://jhinxs.com/intel-vt-x-mini-vt-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
    <description><![CDATA[Intel VT-x是Intel芯片用于支持硬件虚拟化的一种技术，个人理解是在传统的操作系统之上，创建专用于虚拟化开发者的特权级环境，这种权限甚至高于操作系统的环境，也就是常说的Hypervisor层，同样的，新的环境也会引入一些新的特权指令等新的功能。在设计架构上和SVM类似，分为VMM和VMGUEST两种角色，分别处于VMX-ROOT和VMX-NO ROOT模式下

对于虚拟机来说，Hypervisor是完全透明的，当Guest客户机发生vmexit事件后会陷入到Hypervisor，此时控制权完全交与Hypervisor，而Hypervisor同样可以通过vmlaunch运行虚拟机，或者在处理完vmexit事件后，通过vmresume指令，继续运行虚拟机
VT框架实现流程 本代码用于学习研究，运行于32位操作系统之上，在代码实现VT的时候，主要是需要遵循Intel开发手册的标准，我这里实现的时候，大概是以下的流程:
 判断当前CPU是否支持VT技术，通过执行cpuid指令，获取返回信息并判断对应的标志位，这是硬件层面的要求 读取MSR_IA32_FEATURE_CONTROL MSR寄存器对应标志位，用于判断在BIOS配置中是否开启了VT 检查并设置CR4 VMXE标志位 分配4K对齐的内存，用于vmx操作，这块区域按照白皮书的定义一般叫做VMXON region 初始化VMXON region区域，主要是写入一个VMCS版本号，这个版本号通过读取 IA32_MSR_VMX_BASIC MSR寄存器获得 执行VMXON,并检查EFLAGE.CF位是否置0，判断是否执行成功 分配4K对齐的内存，用于逻辑处理器也即虚拟机的操作区域，叫做VMCS region 调用vmclear指令，将VMCS区域设置为清除状态，也即区域初始化 调用vmptrld指令，激活VMCS 为host以及guest分配内存空间 填充VMCS区域，这是最重要也是最复杂的一步 通过vmlaunch运行虚拟机  代码部分 这个代码写的也是一波三折，蓝屏N次，也是各种坑，虽然可以有参考代码，但实际上有很多因素，遇到比如像保存现场代码的优化，多核处理等等诸多问题
首先是开启VT的前期，检测阶段，首先就是通过CPUID指令，这个指令执行前，需要将EAX寄存器置为1，返回值会存在ECX寄存器中，这里CPUID置1是Intel的要求，如果EAX中是其他值，返回的信息也是不同的，只是在这里用作CPU VTZ支持检测，EAX需要置1

1 2 3 4 5 6 7 8 9 10 11 12  get_cpuid_info proc,_para:dword pushad mov eax,1H cpuid mov esi,_para mov [esi],ecx popad ret get_cpuid_info endp   然后是读取IA32_FEATURE_CONTROL MSR寄存器,如果在bios启用VT则bit1，bit2或者两者都必须为1，bit1和bit2主要用于设置是否处于SMX Mode（安全扩展模式）下，这里一般检测bit2就可以了
1 2 3 4 5 6  ULONG64 msr = __readmsr(MSR_IA32_FEATURE_CONTROL); if (!]]></description>
</item></channel>
</rss>
